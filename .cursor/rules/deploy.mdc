---
alwaysApply: true
---

# Project Context & Deployment Rules

## 1. Infrastructure & Tech Stack
- **Code Hosting:** GitHub
- **Web Deployment:** Vercel
- **Desktop Build:** Tauri (cross-platform: Windows, macOS, Linux)
- **Backend/Database:** Supabase
- **Project Name/Context:** Ace IELTS

## 2. Deployment Modes

### SaaS Mode (Cloud-Hosted)
- **Target Users:** End users who want a ready-to-use service
- **Infrastructure:** Hosted on Vercel + Supabase Cloud
- **LLM API:** Managed by the platform (users pay subscription)
- **Database:** Shared Supabase instance with Row Level Security (RLS)

### Self-Hosted Mode (Open Source)
- **Target Users:** Developers, enterprises, privacy-conscious users
- **Infrastructure:** User deploys on their own servers or locally
- **LLM API:** User provides their own OpenAI-compatible API key
- **Database:** User's own Supabase instance or local PostgreSQL

## 3. Environments & URLs

| Environment | URL | Description |
| :--- | :--- | :--- |
| **Production (SaaS)** | `https://www.ace-ielts.net` | Live cloud service (Vercel) |
| **Development** | `http://localhost:3000` | Local web testing |
| **Desktop Dev** | `tauri dev` | Local desktop testing |

## 4. Environment Variables

### Common Variables (All Modes)
```env
VITE_SUPABASE_URL=<supabase_project_url>
VITE_SUPABASE_ANON_KEY=<supabase_anon_key>
```

### Deployment Mode Configuration
```env
# SaaS Mode
VITE_DEPLOYMENT_MODE=saas
VITE_LLM_API_KEY=<platform_managed_key>  # Server-side only

# Self-Hosted Mode
VITE_DEPLOYMENT_MODE=self-hosted
# LLM_API_KEY is configured by user in Settings UI
```

### Desktop-Specific
```env
TAURI_PRIVATE_KEY=<signing_key>  # For update signing
TAURI_KEY_PASSWORD=<key_password>
```

## 5. Deployment Workflow Rules

### GitHub (Source Control)
- **Main Branch:** The `main` branch is the source of truth for Production.
- **Triggers:** Pushing to the `main` branch automatically triggers a Vercel deployment.
- **PRs:** Feature branches should be merged into `main` via Pull Requests.

### Vercel (Web Frontend)
- **Configuration:** Ensure `vercel.json` (if present) or Project Settings match the build command (`pnpm build:web`).
- **Environment Variables:**
  - NEVER hardcode secrets in the frontend code.
  - Use `VITE_` prefix for client-side variables.
  - Ensure Vercel Project Settings have the correct Production Environment Variables set.

### Tauri (Desktop)
- **Build Command:** `pnpm build:desktop`
- **Package Command:** `pnpm package:desktop`
- **Platforms:** Build for Windows (.msi, .exe), macOS (.dmg, .app), Linux (.deb, .AppImage)
- **Auto-Update:** Configure Tauri updater for automatic updates (SaaS mode)

### Supabase (Backend)
- **Connection:** The frontend connects to Supabase using the Project URL and Anon Key.
- **CORS Configuration:** Ensure Supabase Auth settings allow the following Redirect URLs:
  - `http://localhost:3000/**`
  - `https://www.ace-ielts.net/**`
  - `tauri://localhost/**` (for desktop OAuth)
- **Migrations & SQL Management:**
  - **Source of Truth:** SQL statements and schema definitions in `supabase/migrations/` directory.
  - **Workflow:** Create or edit SQL files within `supabase/migrations/`.
  - **Prohibition:** Do not perform schema changes via Supabase Dashboard SQL Editor for permanent changes.

### Supabase Edge Functions (Backend API)
- **Architecture Principle:** All backend operations MUST be implemented as Supabase Edge Functions.
- **Location:** Edge Functions are stored in `supabase/functions/` directory.
- **Language:** TypeScript/Deno runtime.
- **Structure:**
  - Each function has its own directory: `supabase/functions/<function-name>/index.ts`
  - Shared utilities can be placed in `supabase/functions/_shared/` (if needed)
  - Use `deno.json` for Deno configuration and imports
- **Deployment:**
  - **Local Development:** Use `supabase functions serve <function-name>` for local testing.
  - **Production:** Deploy via `supabase functions deploy <function-name>` or CI/CD pipeline.
  - **Environment Variables:** Store secrets in Supabase Dashboard → Edge Functions → Secrets.
  - **Version Control:** Edge Functions code is versioned in Git, but secrets are managed separately.
- **Frontend Integration:**
  - Frontend services call Edge Functions via `supabase.functions.invoke()`.
  - Edge Functions handle all business logic, database operations, and external API calls.
  - Frontend remains lightweight and portable (no direct database queries except simple reads with RLS).
- **Function Naming Convention:** Use kebab-case (e.g., `vocabulary-create-book`, `word-enrich-details`, `gemini-enrich-word`).
- **Error Handling:** Edge Functions return standardized error responses that frontend services can handle uniformly.
- **Request/Response Format:**
```typescript
// Edge Function request handler pattern
Deno.serve(async (req) => {
  try {
    const { data } = await req.json()
    // Validate input
    // Perform operation
    // Return success response
    return new Response(JSON.stringify({ success: true, data: result }), {
      headers: { "Content-Type": "application/json" }
    })
  } catch (error) {
    return new Response(JSON.stringify({ 
      success: false, 
      error: error.message 
    }), {
      status: 400,
      headers: { "Content-Type": "application/json" }
    })
  }
})
```
- **Authentication:** Edge Functions receive Supabase auth token via `Authorization` header. Use `createClient()` with service role key for server-side operations.
- **Benefits:**
  - **Portability:** Frontend can be packaged for Web, Desktop (Tauri), Mobile without backend code changes
  - **Security:** API keys and secrets never exposed to frontend
  - **Scalability:** Edge Functions auto-scale and run close to users
  - **Maintainability:** Backend logic centralized in one place

## 6. Coding Standards for Deployment

### Backend Architecture (Edge Functions First)
- **Principle:** All backend operations MUST be implemented as Supabase Edge Functions.
- **Frontend Services:** Services in `packages/core/src/services/` should call Edge Functions, not directly query Supabase tables.
- **Exceptions (Direct Supabase Access Allowed):**
  - Authentication operations (sign in, sign out, session management)
  - Simple read queries protected by Row Level Security (RLS)
  - Real-time subscriptions for UI updates
- **Edge Function Call Pattern:**
```typescript
// packages/core/src/services/example.ts
import { getSupabase } from "./supabase"

export async function createBook(data: CreateBookInput): Promise<Book> {
  const supabase = getSupabase()
  
  const { data: result, error } = await supabase.functions.invoke('vocabulary-create-book', {
    body: data
  })
  
  if (error) {
    throw new Error(`Failed to create book: ${error.message}`)
  }
  
  return result
}
```

### Environment Variable Handling
- **Dynamic URLs:** Do not hardcode `https://www.ace-ielts.net` or `localhost` in fetch/axios calls.
- **Implementation:** Use `packages/core/src/config/` for deployment-specific configuration.
- **Edge Function URLs:** Automatically resolved via Supabase client, no manual URL construction needed.

### Deployment Mode Checks
```typescript
// packages/core/src/config/deployment.ts
export type DeploymentMode = "saas" | "self-hosted"

export function getDeploymentMode(): DeploymentMode {
  return (import.meta.env.VITE_DEPLOYMENT_MODE as DeploymentMode) || "self-hosted"
}

export function isSaaSMode(): boolean {
  return getDeploymentMode() === "saas"
}
```

### LLM API Configuration
- **SaaS Mode:** API key managed server-side in Edge Functions (via Supabase Secrets), users don't see it
- **Self-Hosted Mode:** Provide Settings UI for users to input their own API key
- **Storage:** Self-hosted API keys stored securely (encrypted in local storage or Supabase)
- **Edge Function Access:** Edge Functions read API keys from Supabase Secrets (SaaS) or user settings table (self-hosted)

### Feature Flags
```typescript
// Use deployment mode for feature availability
if (isSaaSMode()) {
  // Show subscription/billing features
} else {
  // Show API key configuration
}
```

### Frontend Portability Requirements
- **Lightweight Frontend:** Frontend code should be minimal and portable across platforms (Web, Desktop, Mobile).
- **No Heavy Dependencies:** Avoid server-side Node.js APIs, file system operations, or platform-specific code in shared packages.
- **Platform Adapters:** Use adapter pattern (see `monorepo.mdc`) for platform-specific functionality.
- **Edge Functions as Backend:** All complex logic, database writes, and external API calls happen in Edge Functions, keeping frontend thin.
